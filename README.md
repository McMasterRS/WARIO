# WARIO Backend

This library acts as the back-end for the WARIO Editor, running pipelines defined by the .JSON files it creates. Its released separately to allow for the development of custom front-ends, as well as direct integration of a WARIO pipeline into an existing system.

## Using the WARIO Backend

Currently, the primary method for using the WARIO Backend is through the [Wario Editor](https://github.com/McMasterRS/WARIO-Editor). Additionally, JSON files created by this editor can be loaded directly into a WARIO pipeline.

### Threaded Pipeline

The recommended option for running a WARIO pipeline is via the `PipelineThread` class, creating a threaded pipeline. This avoids issues of hanging during long pipeline computation and allows for an interface to display pipeline progress and output.

First, input the PipelineThread class

```python3
from wario import PipelineThread
```
Then, pass the pipeline JSON file to the thread to be ran

```python3
PipelineThread("pipeline_file.json").start()
```
This code can be imbedded in an interface to display information generated by the pipeline. Data can be transfered directly from the pipeline to the interface through the use of Blinker signals.

### Serial Pipeline

There are times where the pipeline requires non thread-safe code and cannot use the PipelineThread function. In these cases, you can directly build the pipeline using the `Pipeline` class

First, import the class and create the pipeline

```python3
from wario.pipeline.Pipeline import Pipeline
from wario.pipeline.JsonInterface import JsonInterface

nodes, connections, globals = JsonInterface.load("pipeline_file.json")
pipeline = Pipeline(global_vars = globals)

for node in nodes:
  pipeline.add(node[1])

for con in connections
  pipeline.connect(parent = conn[0], child = conn[1])
```

Now the pipeline can be ran as before using the start function

```python3
pipeline.start()
```

### Included Signals
These signal names are case sensitive

* **start** - Triggers at the start of pipeline execution
* **end** - Triggers at pipeline completion
* **node start** - Triggers at the start of a node's execution. Contains the name of the node being ran under the 'name' variable
* **node complete** - Triggers on node completion. Also contains the 'name' variable
* **crash** - Triggers on error during node execution. Only included for threaded pipeline

To use a signal, import the blinker library and connect the signal to the function to be triggered

```python3
from blinker import signal

signal("end").connect(finishRun)

def finishRun(sender):
  print("Finished!")
```
The name variables given by the **node start** and **node complete** signals can be accessed as seen below

```python3
def nodeStarted(sender, **kw):
  print("Node Complete: " + kw["name"])
```

## Requirements
* PyQt5
* blinker
